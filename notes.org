* Introduction: Hello, World Below
This book takes a bottom-up approach.
** Quotes
"The true voyage of discovery consists not of going to new places, but of having a new pair of eyes."
- Marcel Proust

"The only kind of learning which significantly influences behavior is self-discovered or self-appropriated -- truth that has been assimilated in experience."
- Carl Rogers

"What is last in the order of analysis seems to be first in the order of becoming."
- Aristotles
* Chapter 1 - Boolean Logic
"Such simple things, And we make of them something so complex it defeats us, Almost."
- John Ashbery

All chips are made of elementary logic gates. There are multiple ways to physically implement these gates, but their logical behavior is consistent.
** 1.1 - Background
*** Elementary boolean operators
Every possible boolean function can be implemented using any of the following:
- and, or, not
- nand
- nor
*** 16 boolean functions
There are 16 boolean functions with 2 inputs and one output.

There are two inputs, each of which may have two states, so we have 2^2 = 4 possible inputs to our boolean function.

For each of the 4 inputs into the boolean function, there are two possible outputs. So we have 2^2^2 = 16 possible boolean functions.
** 1.2 - Specification
*** Multiplexer and demultiplexer
A "multiplexer" is a type of gate that takes 2 inputs, and a selector (which is a 3rd input, of sorts), and outputs one of the two inputs based on the selector value.

A "demultiplexer" is the opposite. There is a single input, and a selector (which is a 2nd input, of sorts), and outputs the input to one of two possible outputs based on the selector value.
*** Multi-bit gates (bus gates)
Gates usually work on many bits at a time. These many bits are called a "buses".

For example, a 32-bit "or" gate would take two arrays, each containing 32-bits, and perform an "or" operation on each pair of bits, then output a single 32-bit array.
*** Gates with many inputs
"And" and "Or" gates naturally extend to taking many inputs. For example, a 16-way "And" gate would take 16 inputs, and output 1 only if all 16 inputs were 1.
*** Complex multiplexers and demultiplexers
Multiplexer and demultiplexers that have more than 2 inputs or outputs will require multiple bit selectors.
** 1.4 - Perspective
We've paid no attention to efficiency considerations such as number of gates used or the number of wire crossovers.
** Exercises
*** Boolean algebra is useful in simplifying circuits
If you turn a truth table into a boolean formula, you can use boolean algebra to simplify the circuit.

There are things called Karnaugh maps which some say help with the simplification.

Also, saying ~A'~ (with a prime) is a better notation for "not A". It's easier to type for one thing, and also ~A+B~ with a line over the whole thing could mean ~(A+B)'~ or ~(A'+B')~.
*** I cheated
I had to look up an efficient way to build a multiplexor. I was suprised to see it could be done with just 4 nand gates. I could have implemented less efficient multiplexor on my own.
*** Simplifying the Multiplexor
The instructions say:
#+BEGIN_EXAMPLE
/**
 * Multiplexor:
 * out = a if sel == 0
 *       b otherwise
 */
#+END_EXAMPLE

Truth table:
#+BEGIN_EXAMPLE
a b sel | out
0 0  0  |  0
0 0  1  |  0
0 1  0  |  0
0 1  1  |  1
1 0  0  |  1
1 0  1  |  0
1 1  0  |  1
1 1  1  |  1
#+END_EXAMPLE

Simplify the standard formula using boolean algebra:
#+BEGIN_EXAMPLE
a'bs + ab's' + abs' + abs
a'bs + as'(b' + b) + abs
a'bs + as' + abs
as' + a'bs + abs
as' + bs(a' + a)
as' + bs

Note: (x or y) = not (x and y) = (x' and' y')

(as')' .' (bs)'
(a .' s') .' (b .' s)
#+END_EXAMPLE

The implementation:
#+BEGIN_EXAMPLE
CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    Not(in=sel, out=notSel);
    Nand(a=a, b=notSel, out=nandA);
    Nand(a=sel, b=b, out=nandB);
    Nand(a=nandA, b=nandB, out=out);
}
#+END_EXAMPLE
*** Three ways to simplify boolean functions
- Boolean algebra
- Karnaugh maps
- Quine-McCluskey
*** Simplifying boolean functions is hard
After some tangental study, I've realized circuit optimization is hard, and could fill an entire course of study. I've only been trying to optimize the number of nand gates, but reality would be even more compilcated with costs and efficiency concerns. Quantum physics would even be an issue. I'm going to leave the issue and focus on creating gates that are simple and good-enough, and if I want to worry about optimizing them later I can.
* Appendix A (HDL) - Sections A1-A6
** Example
#+BEGIN_SRC
/** Checks if two 3-bit input buses are equal */
CHIP EQ3 {
    IN a[3], b[3];
    OUT out; // True iff a=b
    PARTS:
    Xor(a=a[0], b=b[0], out=c0);
    Xor(a=a[1], b=b[1], out=c1);
    Xor(a=a[2], b=b[2], out=c2);
    Or(a=c0, b=c1, out=c01);
    Or(a=c01, b=c2, out=neq);
    Not(in=neq, out=out);
}
#+END_SRC

When we use gates (which look like function calls) like ~Xor(...)~, it is assumed that there is a ~Xor.hdl~ file containing the implementation of ~Xor~.
* TODO Hardware Simulator Tutorial - Parts I, II, and III
